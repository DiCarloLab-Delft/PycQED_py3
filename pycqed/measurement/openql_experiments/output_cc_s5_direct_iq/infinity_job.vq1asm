# Program: 'infinity_job'
# CC_BACKEND_VERSION 0.2.5
# OPENQL_VERSION 0.8.1.dcl-3
# Note:    generated by OpenQL Central Controller backend
#
# synchronous start and latency compensation
                add             R63,1,R0                # R63 externally set by user, prevent 0 value which would wrap counter
                seq_bar         20                      # synchronization
syncLoop:       seq_out         0x00000000,1            # 20 ns delay
                loop            R0,@syncLoop            # 
mainLoop:                                               # 
### Kernel: 'default_1'
## Bundle 0: start_cycle=1, duration_in_cycles=7500:
 # READOUT: prepz(q0)
        
## Bundle 1: start_cycle=2, duration_in_cycles=7500:
 # READOUT: prepz(q4)
 # READOUT: prepz(q3)
 # READOUT: prepz(q2)
 # READOUT: prepz(q1)
        
## Bundle 2: start_cycle=7501, duration_in_cycles=1:
 # gate 'ry90 q0 0'
  # slot=2, instrument='mw_0', group=0': signal='[ry90 q0-mw_0:0-i,ry90 q0-mw_0:0-q]'
 # last bundle of kernel, will pad outputs to match durations
[0]             seq_out         0x00000000,7502         # cycle 0-7502: padding on 'ro_1'
[1]             seq_out         0x00000000,7502         # cycle 0-7502: padding on 'ro_2'
  # slot=2, instrument='mw_0', group=0: codeword=4 (static override): groupDigOut=0x00000004
  # slot=2, instrument='mw_0': lastEndCycle=0, startCycle=7501, slotDurationInCycles=1
[2]             seq_out         0x00000000,7501         # cycle 0-7501: padding on 'mw_0'
[2]             seq_out         0x80000004,1            # cycle 7501-7502: code word/mask on 'mw_0'
[3]             seq_out         0x00000000,7502         # cycle 0-7502: padding on 'mw_1'
[4]             seq_out         0x00000000,7502         # cycle 0-7502: padding on 'flux_0'
        
### Kernel: 'CPhsae_2_for24_start'
# FOR_START(3)
                move            3,R62                   # R62 is the 'for loop counter'
CPhsae:                                                 # 
### Kernel: 'CPhsae_2'
## Bundle 3: start_cycle=1, duration_in_cycles=4:
 # gate 'sf_cz_se q0 0'
  # slot=4, instrument='flux_0', group=0': signal='[flux-0-0]'
 # gate 'sf_cz_nw q2 2'
  # slot=4, instrument='flux_0', group=2': signal='[flux-0-2]'
 # last bundle of kernel, will pad outputs to match durations
[0]             seq_out         0x00000000,5            # cycle 0-5: padding on 'ro_1'
[1]             seq_out         0x00000000,5            # cycle 0-5: padding on 'ro_2'
[2]             seq_out         0x00000000,5            # cycle 0-5: padding on 'mw_0'
[3]             seq_out         0x00000000,5            # cycle 0-5: padding on 'mw_1'
  # slot=4, instrument='flux_0', group=0: codeword=2 (static override): groupDigOut=0x00000002
  # slot=4, instrument='flux_0', group=2: codeword=4 (static override): groupDigOut=0x00000100
  # slot=4, instrument='flux_0': lastEndCycle=0, startCycle=1, slotDurationInCycles=4
[4]             seq_out         0x00000000,1            # cycle 0-1: padding on 'flux_0'
[4]             seq_out         0x80000102,4            # cycle 1-5: code word/mask on 'flux_0'
        
### Kernel: 'CPhsae_2_for24_end'
# FOR_END
                loop            R62,@CPhsae             # R62 is the 'for loop counter'
### Kernel: 'Rot_3'
## Bundle 4: start_cycle=1, duration_in_cycles=1:
 # gate 'rxm90 0'
  # slot=2, instrument='mw_0', group=0': signal='[rxm90-mw_0:0-i,rxm90-mw_0:0-q]'
  # slot=2, instrument='mw_0', group=0: codeword=5 (static override): groupDigOut=0x00000005
  # slot=2, instrument='mw_0': lastEndCycle=0, startCycle=1, slotDurationInCycles=1
[2]             seq_out         0x00000000,1            # cycle 0-1: padding on 'mw_0'
[2]             seq_out         0x80000005,1            # cycle 1-2: code word/mask on 'mw_0'
        
## Bundle 5: start_cycle=2, duration_in_cycles=100:
 # READOUT: measure(q4)
  # slot=0, instrument='ro_1', group=3': signal='[dummy]'
 # READOUT: measure(q3)
  # slot=0, instrument='ro_1', group=2': signal='[dummy]'
 # READOUT: measure(q2)
  # slot=0, instrument='ro_1', group=1': signal='[dummy]'
 # READOUT: measure(q1)
  # slot=1, instrument='ro_2', group=0': signal='[dummy]'
 # READOUT: measure(q0)
  # slot=0, instrument='ro_1', group=0': signal='[dummy]'
 # last bundle of kernel, will pad outputs to match durations
  # slot=0, instrument='ro_1': lastEndCycle=0, startCycle=2, slotDurationInCycles=100
[0]             seq_out         0x00000000,2            # cycle 0-2: padding on 'ro_1'
[0]             seq_out         0x001f0000,100          # cycle 2-102: code word/mask on 'ro_1'
# digIn=30
  # slot=1, instrument='ro_2': lastEndCycle=0, startCycle=2, slotDurationInCycles=100
[1]             seq_out         0x00000000,2            # cycle 0-2: padding on 'ro_2'
[1]             seq_out         0x00030000,100          # cycle 2-102: code word/mask on 'ro_2'
# digIn=2
[2]             seq_out         0x00000000,100          # cycle 2-102: padding on 'mw_0'
[3]             seq_out         0x00000000,102          # cycle 0-102: padding on 'mw_1'
[4]             seq_out         0x00000000,102          # cycle 0-102: padding on 'flux_0'
        
                jmp             @mainLoop               # loop indefinitely
