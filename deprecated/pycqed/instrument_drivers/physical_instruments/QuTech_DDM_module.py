"""
    File:               DDM.py
    Author:             Nikita Vodyagin, QuTech
    Purpose:            control of Qutech DDM
    Prerequisites:
    Usage:
    Bugs:
"""


from .SCPI import SCPI
import numpy as np
import struct
import math
from qcodes import validators as vals
import logging
import time
from qcodes import Parameter
import os
import json
import sys

log = logging.getLogger(__name__)

INT32_MAX = +2147483647
INT32_MIN = -2147483648
CHAR_MAX = +127
CHAR_MIN = -128

FINISH_BIT_CHECK_FERQUENTION_HZ = 25


class DDMq(SCPI):

    exceptionLevel = logging.CRITICAL

    # def __init__(self, logging=True, simMode=False, paranoid=False):
    def __init__(self, name, address, port, **kwargs):
        try:
            super().__init__(name, address, port, **kwargs)
        except Exception as e:
            # Setting up the SCPI sometimes fails the first time.  If this
            # happens a second effort to initialize and settup the connection
            # is made
            print("Failed to connect (" + str(e) + "). The system will retry" +
                  " to connect")
            self.remove_instance(self)
            super().__init__(name, address, port, **kwargs)

        self.device_descriptor = type('', (), {})()
        self.device_descriptor.model = 'DDM'
        self.printAcquisitionProgress = True
        # The next line is needed, because real-time clock of the ddm isn't
        # working properly and start at a fixed start date, instead of the
        # actual date
        self.set_time(int(time.time()))
        self.version_info = self.get_idn()
        self.add_parameters()
        self.connect_message()

    def ask(self, data):
        result = super(DDMq, self).ask(data)
        if (type(result) is str):
            try:
                return float(result)
            except ValueError:
                return result
        return result

    def add_parameter(self, name, parameter_class=Parameter,
                      **kwargs):
        self._setValidatorLimits(name, kwargs)
        super(DDMq, self).add_parameter(name, parameter_class, **kwargs)

    def add_parameters(self):
        self.list_of_parameter_limits = self._read_parameter_limits()
        ddm_parameters = self._read_ddm_parameters()

        # Add the parameters, that where generated by the ddm, to 'self'
        for parameter in ddm_parameters:
            name = parameter["name"]
            del parameter["name"]
            if ("vals" in parameter):
                validator = parameter["vals"]
                try:
                    val_type = validator["type"]
                    if (val_type == "Number"):
                        parameter["vals"] = vals.Numbers(INT32_MIN, INT32_MAX)
                    else:
                        log.warning("Failed to set the validator for the" +
                                    " parameter " + name + ", because of a" +
                                    " unknow validator type: '" + val_type +
                                    "'")
                except Exception as e:
                    log.warning(
                        "Failed to set the validator for the parameter " +
                        name + ".(%s)", str(e))

            try:
                self.add_parameter(name, **parameter)
            except Exception as e:
                log.warning("Failed to create the parameter " + name +
                            ", because of a unknown keyword in this" +
                            " parameter.(%s)", str(e))

        self.add_additional_parameters()

        if (self.version_info['swBuild'] != self.ranges_file_version or
                self.parameter_limits_list_is_incomplete):
            self._store_parameter_limits()

    def add_additional_parameters(self):
        # Ask the ddm how many adcs and qubits per adc it has.
        number_of_adcs = int(self.ask('qutech:nadcs? '))
        number_of_channels = number_of_adcs * 2
        number_of_weigths = []
        for i in range(number_of_adcs):
            number_of_weigths.append(
                int(self.ask('qutech:adc{:d}:nqbits? '.format(i+1))))

        #######################################################################
        # DDM specific
        #######################################################################

        ####################
        # Correlation parameters
        ####################
        self.add_parameter('correlation_data',
                           label=('Get correlation data'
                                  ),
                           docstring='It returns correlatio data written' +
                           ' to correlation memory after measuremnet.' +
                           ' Every weight pair has only one TV mode' +
                           ' memory. It can be used either I or Q ',
                           get_cmd=self._getCorrelationData
                           )
        #################
        # Error fraction
        #################
        self.add_parameter('two_bit_pattern_cnt',
                           label='Get all 2 bit fraction counters ',
                           docstring='It returns 5 counters which' +
                           ' are:  No Error Counter, Single Error' +
                           ' Counter, Double Error CounterReg Zero' +
                           ' State CounterReg,One State CounterReg. ',
                           get_cmd=self._get2BitPatternCnt
                           )
        self.add_parameter('two_bit_pattern_pattern',
                           label='Get 2 bit pattern ',
                           docstring='  ' +
                           '' +
                           ' ',
                           set_cmd=self._send2BitPatternPattern,
                           get_cmd=self._get2BitPatternPattern,

                           vals=vals.Arrays(0b00, 0b11)
                           )
        self.add_parameter('warning_level',
                           label='Setting from what the level for where ' +
                           'errors are considered critical',
                           docstring='On the given level and above, a errors' +
                           ' will cause exceptions, instead logging of the' +
                           ' error.\r\n\r\n' +
                           'Loggin Levels:\r\n' +
                           '50 = CRITICAL\r\n' +
                           '40 = ERROR\r\n' +
                           '30 = WARNING\r\n' +
                           '20 = INFO\r\n' +
                           '10 = DEBUG\r\n' +
                           '0  = NOTSET ',
                           set_cmd=self._setWarningLevel,
                           get_cmd=self._getWarningLevel,
                           )
        self.add_parameter('display_progress_enable',
                           label="Enable or disables printing of the " +
                           "acquisitions' progress during and measurement",
                           docstring=' ',
                           set_cmd=self._setDisplayProgressEnabled,
                           get_cmd=self._getDisplayProgressEnabled,
                           )

        for i in range(number_of_channels//2):
            """
            Channel pair is 2 channel pysically binded in DDM. It can be
            referred to ADC1=ch_pair1 (ch1 and ch2 ) and
            ADC2=ch_pair2(ch3 and ch4) board For the user of DDM, ch_pair
            means a common paramenter (function,method) for two of the
            channels either for ch1,ch2 or ch3,ch4.
            """
            ch_pair = i+1

            self.add_parameter('ch_pair{}_status'.format(ch_pair),
                               label=('Get status '),
                               docstring='It returns status on Over range,' +
                               ' under range on DI and DQ FPGA clock,' +
                               ' Calbration status( in case if is being ' +
                               ' calibrated it will show the warning, False' +
                               ' Trigger for input averaging and integration.',
                               get_cmd=self._gen_ch_get_func(
                                   self._getADCstatus, ch_pair)
                               )
            ################
            # Error fraction
            ################
            self.add_parameter('ch_pair{}_err_fract_pattern'.format(ch_pair),
                               label=('Get error fraction pattern ' +
                                      'ch_pair {}'.format(ch_pair)),
                               docstring='It sets a binary list of 2 value' +
                               ' to set a pattren Next0: Next state when in' +
                               ' ‘0’ Specifies the expected next state when' +
                               ' the current state is ‘0’. Next1: Next ' +
                               ' state when in ‘1’. Specifies the expected' +
                               ' next state when the current state is ‘1’.',
                               set_cmd=self._gen_ch_set_func(
                self._sendErrFractSglQbitPatternAll,
                ch_pair),
                get_cmd=self._gen_ch_get_func(
                self._getErrFractSglQbitPatternAll,
                ch_pair),
                vals=vals.Arrays(0, 1)
            )

            for i in range(number_of_weigths[ch_pair-1]):
                wNr = i+1

                ####################
                # TV mode parameters
                ####################
                self.add_parameter('ch_pair{}_weight{}_tvmode_data'.format(
                                   ch_pair, wNr),
                                   label=('Get TV data channel pair' +
                                          ' {} weight {}'.format(ch_pair, wNr)
                                          ),
                                   docstring='It returns tvmode data written' +
                                   ' to TVmode memory after measuremnet.' +
                                   ' Every weight pair has only one TV mode' +
                                   ' memory. It can be used either I or Q ',
                                   get_cmd=self._gen_ch_weight_get_func(
                                       self._getTVdata, ch_pair, wNr)

                                   )

                ###########################
                # TV mode QSTATE parameters
                ###########################
                self.add_parameter('ch_pair{}_weight{}_qstate_cnt_data'.format(
                                   ch_pair, wNr),
                                   label=('Get qstate counter' +
                                          'ch_pair {} weight {} '.format(
                                              ch_pair, wNr)),
                                   docstring='It returns tvmode data after' +
                                   ' thresholding written to TVmode memory' +
                                   ' after measuremnet and not averaged. ' +
                                   'Every weight pair has only one TV mode' +
                                   ' memory. It can be used either I or Q ' +
                                   'Foramt is float containg 0s and 1s ',
                                   get_cmd=self._gen_ch_weight_get_func(
                                   self._getQstateCNT, ch_pair, wNr)

                                   )
                self.add_parameter('ch_pair{}_weight{}_qstate_avg_data'.format(
                                   ch_pair, wNr),
                                   label=('Get qstate average' +
                                          'ch_pair {} weight {}'.format(
                                              ch_pair, wNr)),
                                   docstring='It returns tvmode data after' +
                                   ' thresholding written to TVmode memory' +
                                   ' after measuremnet and already averaged' +
                                   ' with preset number of averages. Every' +
                                   ' weight pair has only one TV mode memory' +
                                   'It can be used either I or Q Format' +
                                   ' is float containg numbers between 0 and' +
                                   ' 1 ',
                                   get_cmd=self._gen_ch_weight_get_func(
                    self._getQstateAVG, ch_pair, wNr)

                )
                #################
                # Logging
                #################
                self.add_parameter('ch_pair{}_weight{}_logging_int'.format(
                                   ch_pair, wNr),
                                   label=('Get integration logging ' +
                                          'ch_pair {} weight {}'.format(
                                              ch_pair, wNr)),
                                   docstring='It returns Logging integration' +
                                   ' data written to Logging memory after' +
                                   ' measuremnet. It is up to 8192 shots' +
                                   'with preset number of shots. Every' +
                                   ' weight pair has only one TV mode memory' +
                                   'It can be used either I or Q  Foramt is' +
                                   ' float containg 0s and 1s ',
                                   get_cmd=self._gen_ch_weight_get_func(
                                       self._getLoggingInt, ch_pair, wNr),

                                   )
                self.add_parameter('ch_pair{}_weight{}_logging_qstate'.format(
                                   ch_pair, wNr),
                                   label=('Get qstate logging ' +
                                          'ch_pair {} weight {}'.format(
                                              ch_pair, wNr)),
                                   docstring='It returns Logging data after ' +
                                   'thresholding written to Logging memory' +
                                   ' after measuremnet. It is up to 8192' +
                                   ' shots with preset number of shots.' +
                                   ' Every weight pair has only one TV mode' +
                                   ' memory It can be used either I or Q ' +
                                   'Foramt is float containg 0s and 1s ',
                                   get_cmd=self._gen_ch_weight_get_func(
                                       self._getLoggingQstate, ch_pair, wNr),

                                   )
                #################
                # Error fraction
                #################
                self.add_parameter('ch_pair{}_weight{}_err_fract_cnt'.format(
                                   ch_pair, wNr),
                                   label=('Get all error fraction counters ' +
                                          'ch_pair {} weight {}'.format(
                                              ch_pair, wNr)),
                                   docstring='It returns 5 counters which' +
                                   ' are:  No Error Counter, Single Error' +
                                   ' Counter, Double Error CounterReg Zero' +
                                   ' State CounterReg,One State CounterReg. ',
                                   get_cmd=self._gen_ch_weight_get_func(
                                       self._getErrFractCnt, ch_pair, wNr)

                                   # vals=vals.Numbers(-128,127)
                                   )
                self.add_parameter(('ch_pair{}_weight{}_err_fract_pattern'
                                    ).format(ch_pair, wNr),
                                   label=('Get error fraction pattern ' +
                                          'ch_pair {} weight {}'.format(
                                              ch_pair, wNr)),
                                   docstring='  ' +
                                   '' +
                                   ' ',
                                   set_cmd=self._gen_ch_weight_set_func(
                                       self._sendErrFractSglQbitPattern,
                                       ch_pair, wNr),
                                   get_cmd=self._gen_ch_weight_get_func(
                                       self._getErrFractSglQbitPattern,
                                       ch_pair, wNr),

                                   vals=vals.Arrays(0, 1)
                                   )
        ###################
        # Sorted by channel
        ###################
        for i in range(number_of_channels):
            ch = i+1
            self.add_parameter('ch{}_inavg_data'.format(ch),
                               label=('Get data ch {} '.format(ch)),
                               docstring='It returns input averaging data' +
                               ' written to input averaging memory after' +
                               ' measuremnet. It is up to 4096 samples (8us)' +
                               'with preset number of samples. Every channel' +
                               ' has its input averaging memory Foramt is ' +
                               'integer from -128 to 127 corrsponding to +-1V',
                               get_cmd=self._gen_ch_get_func(
                                   self._getInputAverage, ch),
                               vals=vals.Arrays(-128, 127)
                               )
            srotres_cmd = 'qutech:wintrot{}:result'.format(ch)
            self.add_parameter('ch{}_wintrot_result'.format(ch),
                               unit='#',

                               label=('Rotated integration result of' +
                                      'channel {} '.format(ch)),
                               docstring='Not used  ' +
                               '' +
                               ' ',
                               get_cmd=srotres_cmd + '?'
                               )
            for i in range(number_of_weigths[ch_pair-1]):
                wNr = i+1
                self.add_parameter(
                    'ch{}_weight{}_data'.format(ch, wNr),
                    label=('Get weight data channel {}'.format(ch) +
                           'weight number {}  '.format(wNr)),
                    docstring='It set a weight up 4096 samples (8 us) per' +
                    ' channel and weight pair. It is int8 integer between' +
                    ' -128 to 127 corresponding +-1V. It should be' +
                    ' re-factored before setting or getting ',
                    get_cmd=self._gen_ch_weight_get_func(
                        self._getWeightData, ch, wNr),
                    set_cmd=self._gen_ch_weight_set_func(
                        self._sendWeightData, ch, wNr),
                    vals=vals.Arrays(-128, 127)
                )

    #################
    # Set Validator Limits
    #################

    def _ask(self, data):
        if (isinstance(data, str)):
            return self.ask(data)
        else:
            return data()

    def _write(self, func, data):
        if (isinstance(func, str)):
            return self.write(func.format(data))
        else:
            return func(data)

    # Make use of the validators' limits that are stored in a txt file
    def _setValidatorLimits(self, name, kwargs):
        if ('vals' in kwargs and 'set_cmd' in kwargs and 'get_cmd' in kwargs):
            if (self.version_info['swBuild'] != self.ranges_file_version or
                    not (name in self.list_of_parameter_limits)):
                self._updateValidatorLimits(name, kwargs)
            try:
                min_value = self.list_of_parameter_limits[name]["min_val"]
                max_value = self.list_of_parameter_limits[name]["max_val"]
                validator = kwargs['vals']
                if (isinstance(validator, vals.Numbers)):
                    if (str(validator._min_value) != min_value
                            or str(validator._max_value) != max_value):
                        kwargs['vals'] = vals.Numbers(
                            float(min_value), float(max_value))
                elif (isinstance(validator, vals.Arrays)):
                    if (str(validator._min_value) != min_value
                            or str(validator._max_value) != max_value):
                        kwargs['vals'] = vals.Arrays(float(min_value), float(
                            max_value))
                else:
                    log.debug("Not implemented: Setting of min and max" +
                              " values of a parameter from the ddm of type '" +
                              type(validator) + "'")
            except Exception as e:
                log.debug("Exception was thrown while setting the min and" +
                          " max values of a parameter '" + name + "' from" +
                          " the ddm.(%s)", str(e))

    # Get the min and max values of a parameter from the ddm
    def _updateValidatorLimits(self, name, kwargs):
        try:
            min_value = str(INT32_MIN)
            max_value = str(INT32_MAX)
            validator = kwargs['vals']
            if (isinstance(validator, vals.Numbers)):
                initialValue = self._ask(kwargs['get_cmd'])
                self._write(kwargs['set_cmd'], str(INT32_MAX))
                max_value = self._ask(kwargs['get_cmd'])
                self._write(kwargs['set_cmd'], str(INT32_MIN))
                min_value = self._ask(kwargs['get_cmd'])
                self._write(kwargs['set_cmd'], initialValue)
            elif (isinstance(validator, vals.Arrays)):
                initialValue_str = self._ask(kwargs['get_cmd'])
                initialValue = list(map(int, initialValue_str))
                count = max(1, len(initialValue))
                char_max = []
                char_min = []
                for i in range(count):
                    char_max.append(CHAR_MAX)
                    char_min.append(CHAR_MIN)
                self._write(kwargs['set_cmd'], char_max)
                max_value = str(self._ask(kwargs['get_cmd'])[0])
                self._write(kwargs['set_cmd'], char_min)
                min_value = str(self._ask(kwargs['get_cmd'])[0])
                self._write(kwargs['set_cmd'], initialValue)
            else:
                log.debug("Not implemented: Retreiving min and" +
                          " max values of a parameter from the" +
                          " ddm of type '" + type(validator) + "'")
            self.list_of_parameter_limits[name] = {}
            self.list_of_parameter_limits[name]["min_val"] = min_value
            self.list_of_parameter_limits[name]["max_val"] = max_value
            self.parameter_limits_list_is_incomplete = True
        except Exception as e:
            log.debug("Exception was thrown while retreiving the min and max" +
                      " values of a parameter '" + name + "' from the ddm." +
                      "(%s)", str(e))

    #################
    # Get Data
    #################
    def _getInputAverage(self, ch):
        ch_pair = math.ceil(ch/2)
        finished = '0'
        while (finished != '1'):
            finished = str(self._getInAvgFinished(ch_pair))
            if (finished == 'ffffffff'):
                break
            time.sleep(1.0/FINISH_BIT_CHECK_FERQUENTION_HZ)
        self._displayInAvgErrors("Input Average", ch)
        self.write('qutech:inputavg{:d}:data? '.format(ch))
        binBlock = self.binBlockRead()
        inputavg = np.frombuffer(binBlock, dtype=np.float32)
        return inputavg

    def _getTVdata(self, ch_pair, wNr):
        finished = '0'
        while (finished != '1'):
            finished = str(self._getTVFinished(ch_pair, wNr))
            if (finished == 'ffffffff'):
                break
            elif (finished != '1'):
                if self.printAcquisitionProgress:
                    print("\r TV mode(" + str(int(float(self._getTVpercentage(
                        ch_pair, wNr)))) + "%)", end='\0')
                time.sleep(1.0/FINISH_BIT_CHECK_FERQUENTION_HZ)
        if self.printAcquisitionProgress:
            print("\r", end='\0')
            sys.stdout.flush()
        self._displayQBitErrors("TV Mode", ch_pair, wNr)
        self.write('qutech:tvmode{:d}:data{:d}? '.format(ch_pair, wNr))
        binBlock = self.binBlockRead()
        tvmodedata = np.frombuffer(binBlock, dtype=np.float32)
        return tvmodedata

    def _getCorrelationData(self):
        finished = '0'
        while (finished != '1'):
            finished = str(self._getCorrelationFinished())
            if (finished == 'ffffffff'):
                break
            elif (finished != '1'):
                if self.printAcquisitionProgress:
                    print("\r Correlation (" + str(int(float(
                        self._getCorrelationpercentage()))) + "%)", end='\0')
                time.sleep(1.0/FINISH_BIT_CHECK_FERQUENTION_HZ)
        if self.printAcquisitionProgress:
            print("\r", end='\0')
            sys.stdout.flush()
        self._displayQBitErrors("Correlation", 1, 1)
        self.write('qutech:correlation:data? ')
        binBlock = self.binBlockRead()
        tvmodedata = np.frombuffer(binBlock, dtype=np.float32)
        return tvmodedata

    def _sendWeightData(self, ch, wNr,  weight):
        # generate the binblock
        if 1:   # high performance
            arr = np.asarray(weight, dtype=np.int8)
            binBlock = arr.tobytes()
        else:   # more generic
            binBlock = b''
            for i in range(len(weight)):
                binBlock = binBlock + struct.pack('<f', weight[i])

        # write binblock
        hdr = 'qutech:wint:data {:d}, {:d},'.format(ch, wNr)
        self.binBlockWrite(binBlock, hdr)

    def _getWeightData(self, ch, wNr):
        self.write('qutech:wint{:d}:data{:d}? '.format(ch, wNr))
        binBlock = self.binBlockRead()
        weightdata = np.frombuffer(binBlock, dtype=np.int8)
        return weightdata

    def _getQstateCNT(self, ch_pair, wNr):
        finished = '0'
        while (finished != '1'):
            finished = str(self._getTVFinished(ch_pair, wNr))
            if (finished == 'ffffffff'):
                break
            elif (finished != '1'):
                if self.printAcquisitionProgress:
                    print("\r TV mode(" + str(int(float(self._getTVpercentage(
                          ch_pair, wNr)))) + "%)", end='\0')
                time.sleep(1.0/FINISH_BIT_CHECK_FERQUENTION_HZ)
        if self.printAcquisitionProgress:
            print("\r", end='\0')
            sys.stdout.flush()
        self._displayQBitErrors("TV Mode - Qbit state", ch_pair, wNr)

        self.write('qutech:qstate{:d}:data{:d}:counter? '.format(ch_pair, wNr))
        binBlock = self.binBlockRead()
        qstatecnt = np.frombuffer(binBlock, dtype=np.float32)
        return qstatecnt

    def _getQstateAVG(self, ch_pair, wNr):
        finished = '0'
        while (finished != '1'):
            finished = str(self._getTVFinished(ch_pair, wNr))
            if (finished == 'ffffffff'):
                break
            elif (finished != '1'):
                if self.printAcquisitionProgress:
                    print("\r TV mode(" + str(int(float(self._getTVpercentage(
                        ch_pair, wNr)))) + "%)", end='\0')
                time.sleep(1.0/FINISH_BIT_CHECK_FERQUENTION_HZ)
        if self.printAcquisitionProgress:
            print("\r", end='\0')
            sys.stdout.flush()
        self._displayQBitErrors("TV Mode - Qbit state", ch_pair, wNr)
        self.write('qutech:qstate{:d}:data{:d}:average? '.format(ch_pair, wNr))
        binBlock = self.binBlockRead()
        qstateavg = np.frombuffer(binBlock, dtype=np.float32)
        return qstateavg

    def _getLoggingInt(self, ch_pair, wNr):
        finished = '0'
        while (finished != '1'):
            finished = str(self._getLoggingFinished(ch_pair, wNr))
            if (finished == 'ffffffff'):
                break
            elif (finished != '1'):
                if self.printAcquisitionProgress:
                    print("\r Logging mode(" + str(int(float(
                        self._getLoggingpercentage(ch_pair, wNr)))) + "%)",
                        end='\0')
                time.sleep(1.0/FINISH_BIT_CHECK_FERQUENTION_HZ)
        if self.printAcquisitionProgress:
            print("\r", end='\0')
            sys.stdout.flush()
        self._displayQBitErrors("Logging", ch_pair, wNr)
        self.write('qutech:logging{:d}:data{:d}:int? '.format(ch_pair, wNr))
        binBlock = self.binBlockRead()
        intlogging = np.frombuffer(binBlock, dtype=np.float32)
        return intlogging

    def _getLoggingQstate(self, ch_pair, wNr):
        finished = '0'
        while (finished != '1'):
            finished = str(self._getLoggingFinished(ch_pair, wNr))
            if (finished == 'ffffffff'):
                break
            elif (finished != '1'):
                if self.printAcquisitionProgress:
                    print("\r Logging mode(" + str(int(float(
                        self._getLoggingpercentage(ch_pair, wNr)))) + "%)",
                        end='\0')
                time.sleep(1.0/FINISH_BIT_CHECK_FERQUENTION_HZ)
        if self.printAcquisitionProgress:
            print("\r", end='\0')
            sys.stdout.flush()
        self._displayQBitErrors("Logging - Qbit state", ch_pair, wNr)
        self.write('qutech:logging{:d}:data{:d}:qstate? '.format(ch_pair, wNr))
        binBlock = self.binBlockRead()
        qstatelogging = np.frombuffer(binBlock, dtype=np.float32)
        return qstatelogging

    #################
    # Input averaging
    #################
    def _getInAvgStatus(self, ch_pair):
        return self.ask('qutech:inputavg{:d}:status? '.format(ch_pair))

    def _getInAvgFinished(self, ch_pair):
        finished = self.ask('qutech:inputavg{:d}:finished? '.format(ch_pair))
        fmt_finished = format(int(float(finished)), 'x')
        return fmt_finished

    def _getInAvgBusy(self, ch_pair):
        return self.ask('qutech:inputavg{:d}:busy? '.format(ch_pair))

    #################
    # TV MODe
    #################
    def _getTVStatus(self, ch_pair, wNr):
        return self.ask('qutech:tvmode{:d}:status{:d}? '.format(ch_pair, wNr))

    def _getTVFinished(self, ch_pair, wNr):
        finished = self.ask(
            'qutech:tvmode{:d}:finished{:d}? '.format(ch_pair, wNr))
        fmt_finished = format(int(float(finished)), 'x')
        return fmt_finished

    def _getTVBusy(self, ch_pair, wNr):
        return self.ask('qutech:tvmode{:d}:busy{:d}? '.format(ch_pair, wNr))

    def _getTVpercentage(self, ch_pair, wNr):
        return self.ask('qutech:tvmode{:d}:percentage{:d}? '.format(
            ch_pair, wNr))

    #################
    # Logging
    #################
    def _getLoggingFinished(self, ch_pair, wNr):
        finished = self.ask(
            'qutech:logging{:d}:finished{:d}? '.format(ch_pair, wNr))
        fmt_finished = format(int(float(finished)), 'x')
        return fmt_finished

    def _getLoggingBusy(self, ch_pair, wNr):
        return self.ask('qutech:logging{:d}:busy{:d}? '.format(ch_pair, wNr))

    def _getLoggingpercentage(self, ch_pair, wNr):
        return self.ask('qutech:logging{:d}:percentage{:d}? '.format(
            ch_pair, wNr))

    def _getLoggingStatus(self, ch_pair, wNr):
        return self.ask('qutech:errorfraction{:d}:status{:d}? '.format(
            ch_pair, wNr))

    #################
    # Correlation Mode
    #################
    def _getCorrelationStatus(self):
        return self.ask('qutech:correlation:status? ')

    def _getCorrelationFinished(self):
        finished = self.ask('qutech:correlation:finished? ')
        fmt_finished = format(int(float(finished)), 'x')
        return fmt_finished

    def _getCorrelationBusy(self):
        return self.ask('qutech:correlation:busy? ')

    def _getCorrelationpercentage(self):
        return self.ask('qutech:correlation:percentage? ')

    #########################
    # Error fraction counters
    #########################
    def _sendErrFractSglQbitPatternAll(self, ch_pair, pattern):
        self.write('qutech:errorfraction{:d}:pattern:all {:d},{:d}'.format(
                   ch_pair, pattern[0], pattern[1]))

    def _getErrFractSglQbitPatternAll(self, ch_pair):
        pstring = self.ask(
            'qutech:errorfraction{:d}:pattern:all? '.format(ch_pair))
        P = np.zeros(2)
        for i, x in enumerate(pstring.split(',')):
            P[i] = x
        return (P)

    def _sendErrFractSglQbitPattern(self, ch_pair, wNr, pattern):
        self.write('qutech:errorfraction{:d}:pattern{:d} {:d},{:d}'.format(
                   ch_pair, wNr, pattern[0], pattern[1]))

    def _getErrFractSglQbitPattern(self, ch_pair, wNr):
        pstring = self.ask(
            'qutech:errorfraction{:d}:pattern{:d}? '.format(ch_pair, wNr))
        P = np.zeros(2)
        for i, x in enumerate(pstring.split(',')):
            P[i] = x
        return (P)

    def _getErrFractCnt(self, ch_pair, wNr):
        finished = '0'
        while (finished != '1'):
            finished = str(self._getErrFractFinished(ch_pair, wNr))
            if (finished == 'ffffffff'):
                break
            elif (finished != '1'):
                if self.printAcquisitionProgress:
                    print("\r Error fraction mode(" + str(int(float(
                        self._getErrFractpercentage(ch_pair, wNr)))) + "%)",
                        end='\0')
                time.sleep(1.0/FINISH_BIT_CHECK_FERQUENTION_HZ)
        if self.printAcquisitionProgress:
            print("\r", end='\0')
            sys.stdout.flush()
        self._displayQBitErrors("Error Fract", ch_pair, wNr)

        self.write('qutech:errorfraction{:d}:data{:d}? '.format(ch_pair, wNr))
        binBlock = self.binBlockRead()
        errfractioncnt = np.frombuffer(binBlock, dtype=np.int32)
        print('NoErrorCounterReg    = {:d}'.format(errfractioncnt[0]))
        print('SingleErrorCounterReg= {:d}'.format(errfractioncnt[1]))
        print('DoubleErrorCounterReg= {:d}'.format(errfractioncnt[2]))
        print('ZeroStateCounterReg  = {:d}'.format(errfractioncnt[3]))
        print('OneStateCounterReg   = {:d}'.format(errfractioncnt[4]))
        return errfractioncnt

    def _getErrFractFinished(self, ch_pair, wNr):
        finished = self.ask(
            'qutech:errorfraction{:d}:finished{:d}? '.format(ch_pair, wNr))
        fmt_finished = format(int(float(finished)), 'x')
        return fmt_finished

    def _getErrFractBusy(self, ch_pair, wNr):
        return self.ask('qutech:errorfraction{:d}:busy{:d}? '.format(
            ch_pair, wNr))

    def _getErrFractpercentage(self, ch_pair, wNr):
        return self.ask('qutech:errorfraction{:d}:percentage{:d}? '.format(
            ch_pair, wNr))

    def _getErrFractStatus(self, ch_pair, wNr):
        return self.ask('qutech:errorfraction{:d}:status{:d}? '.format(
            ch_pair, wNr))

    #########################
    # 2 bit pattern
    #########################
    def _send2BitPatternPattern(self, pattern):
        self.write('qutech:twoBitPattern:pattern {:d},{:d},{:d},{:d}'.format(
            pattern[0], pattern[1], pattern[2], pattern[3]))

    def _get2BitPatternPattern(self):
        pstring = self.ask(
            'qutech:twoBitPattern:pattern? ')
        P = np.zeros(4)
        for i, x in enumerate(pstring.split(',')):
            P[i] = x
        return (P)

    def _get2BitPatternCnt(self):
        finished = '0'
        while (finished != '1'):
            finished = str(self._getTwoBitPatternFinished())
            if (finished == 'ffffffff'):
                break
            elif (finished != '1'):
                if self.printAcquisitionProgress:
                    print("\r Two bit pattern counter(" + str(int(float(
                        self._getTwoBitPatternPercentage()))) + "%)", end='\0')
                time.sleep(1.0/FINISH_BIT_CHECK_FERQUENTION_HZ)
        if self.printAcquisitionProgress:
            print("\r", end='\0')
            sys.stdout.flush()
        self._displayQBitErrors("Two Bit Pattern Counter", 1, 1)

        self.write('qutech:twoBitPattern:data? ')
        binBlock = self.binBlockRead()
        errfractioncnt = np.frombuffer(binBlock, dtype=np.int32)
        print('NoErrorCounterReg    = {:d}'.format(errfractioncnt[0]))
        print('SingleErrorCounterReg= {:d}'.format(errfractioncnt[1]))
        print('DoubleErrorCounterReg= {:d}'.format(errfractioncnt[2]))
        print('00StateCounterReg    = {:d}'.format(errfractioncnt[3]))
        print('01StateCounterReg    = {:d}'.format(errfractioncnt[4]))
        print('10StateCounterReg    = {:d}'.format(errfractioncnt[5]))
        print('11StateCounterReg    = {:d}'.format(errfractioncnt[6]))
        return errfractioncnt

    def _getTwoBitPatternFinished(self):
        finished = self.ask('qutech:twoBitPattern:finished? ')
        fmt_finished = format(int(float(finished)), 'x')
        return fmt_finished

    def _getTwoBitPatternBusy(self):
        return self.ask('qutech:twoBitPattern:busy? ')

    def _getTwoBitPatternPercentage(self):
        return self.ask('qutech:twoBitPattern:percentage? ')

    def _getTwoBitPatternStatus(self):
        return self.ask('qutech:twoBitPattern:status? ')

    # Ask for DDM status
    def _getADCstatus(self, ch_pair):
        status = self.ask('qutech:adc{:d}:status? '.format(ch_pair))
        statusstr = format(np.uint32(status), 'b')
        reversestatusstr = statusstr[::-1]
        inavgstatus = self._getInAvgStatus(ch_pair)
        inavgstatusstr = format(np.uint32(inavgstatus), 'b').zfill(32)
        reverseinavgstatus = inavgstatusstr[::-1]
        # only first weight pair is checked
        statuswint = self.ask('qutech:wint{:d}:status{:d}?'.format(ch_pair, 1))
        statuswintstr = format(int(statuswint), 'b').zfill(32)
        reversestatuswintstr = statuswintstr[::-1]
        tempstatus = self._get_temp_status(ch_pair)
        tempstatusstr = format(np.uint32(tempstatus), 'b').zfill(32)
        reversetempstatusstr = tempstatusstr[::-1]

        def _DI():
            if (reversestatusstr[0] == '1'):
                logging.warning('\nOver range on DI input. ')
                return None
            elif(reversestatusstr[1] == '1'):
                logging.warning('\nUnder range on DI input. Input signal is' +
                                ' less than 25% of ADC resolution. ')
                return None
            else:
                print("\nDI input is Okay.")
                return None

        def _DQ():
            if (reversestatusstr[2] == '1'):
                logging.warning('\nOver range on DQ input. ')
            elif(reversestatusstr[3] == '1'):
                logging.warning('\nUnder range on DQ input. Input signal is' +
                                ' less than 25% of ADC resolution. ')
            else:
                print("\nDQ input is Okay.")
            return None

        def _DCLK_PLL_LOCKED():
            if (reversestatusstr[4] == '1'):
                print("\nDCLK PLL has a phase lock. There is an ADC clock.")
            else:
                print("\nThere is no ADC clock.")
            return None

        def _CalRun():
            if (reversestatusstr[5] == '1'):
                logging.warning("\nADC calibration is in progress.")
            else:
                print("\nADC calibration is not in progress.")
            return None

        def _FalseTrig():
            if (reverseinavgstatus[28] == '1'):
                logging.warning("\nFalse trigger detected in Input Averaging" +
                                " mode. \nThe logic will ignore this (false)" +
                                " trigger.\nIndication that a trigger was" +
                                " received while the ADC samples\nof a" +
                                " previous scan were still being processed. ")

            if (reversestatuswintstr[20] == '1'):
                logging.warning("\nFalse Trigger on DI channel.\nThe logic" +
                                " will ignore this (false) trigger." +
                                "\nIndicates that a trigger was received" +
                                " while the ADC samples\nof a previous scan" +
                                " were still being processed. ")
            if (reversestatuswintstr[21] == '1'):
                logging.warning("\nFalse Trigger on DQ channel.\nThe logic" +
                                " will ignore this (false) trigger." +
                                "\nIndicates that a trigger was received" +
                                " while the ADC samples\nof a previous" +
                                " scan were still being processed. ")

            else:
                print("\nNo false trigger.Trigger period is okay.")
            return None

        def _Temperature():
            # print("\nDictionary with temperature information and" +
            #      " recommendations." +
            #      "\nCheck WarnMessage for the recommendation:")
            if (reversetempstatusstr[1] == '1'):
                logging.warning("\nADC Temperature is Critical!")

            elif (reversetempstatusstr[0] == '1'):
                logging.warning(
                    "\nADC Temperature change is more than 2°C. " +
                    "Re-calibration is advised!")

            else:
                print("\nADC Temperature is okay.")

            return None

        ADCstatus = {0: _DI,
                     1: _DQ,
                     2: _DCLK_PLL_LOCKED,
                     3: _CalRun,
                     4: _FalseTrig,
                     5: _Temperature,
                     }

        for x in range(0, 6):
            print(ADCstatus[x]())

        return None
        # return None

    # Get threshold value form channel pair, weight number(qubit)
    def _getTHL(self, ch_pair, weight_nr):
        ret = self.ask(
            'qutech:qstate{}:threshold{:d}?'.format(ch_pair, weight_nr))
        return ret

    # to be able to set ch/ch_pair in getcmd
    def _gen_ch_get_func(self, fun, ch):
        def get_func():
            return fun(ch)
        return get_func

    # to be able to set ch/ch_pair  in setcmd
    def _gen_ch_set_func(self, fun, ch):
        def set_func(val):
            return fun(ch, val)
        return set_func

    # to be able to set ch/ch_pair and weight(qbit) number in getcmd
    def _gen_ch_weight_get_func(self, fun, ch, wNr):
        def get_func():
            return fun(ch, wNr)
        return get_func

    # to be able to set ch/ch_pair and weight(qbit) number in setcmd
    def _gen_ch_weight_set_func(self, fun, ch, wNr):
        def set_func(val):
            return fun(ch, wNr, val)
        return set_func

    # get time on DDM (Linux kernel clock)
    def get_time(self):
        timesec = self.ask('system:time?')
        return int(timesec)

    # set time on DDM (Linux kernel clock)
    def set_time(self, timesec):
        self.write('system:time {:d}'.format(timesec))

    def _get_temp_status(self, ch_pair):
        temp = self.ask('qutech:adc{:d}:temperature:status? '.format(ch_pair))
        return int(temp)

    def _get_weigth_data_status(self, ch_pair):
        status = self.ask('qutech:adc{:d}:weightdata:status? '.format(ch_pair))
        return int(status)

    # Overloding get_idn function to format DDM versions
    def get_idn(self):
        try:
            idstr = ''  # in case self.ask fails
            idstr = self.ask('*IDN?')
            # form is supposed to be comma-separated, but we've seen
            # other separators occasionally
            for separator in ',;:':
                # split into no more than 4 parts, so we don't lose info
                idparts = [p.strip() for p in idstr.split(separator, 8)]
                if len(idparts) > 1:
                    break
            # in case parts at the end are missing, fill in None
            if len(idparts) < 9:
                idparts += [None] * (9 - len(idparts))
            for i in range(0, 9):
                idparts[i] = idparts[i].split('=')[1]
        except Exception:
            logging.warn('Error getting or interpreting *IDN?: ' + repr(idstr))
            idparts = [None, None, None, None, None, None]

        # some strings include the word 'model' at the front of model
        if str(idparts[1]).lower().startswith('model'):
            idparts[1] = str(idparts[1])[9:].strip()

        return dict(zip(('vendor', 'model', 'serial', 'fwVersion', 'fwBuild',
                         'swVersion', 'swBuild', 'kmodVersion',
                         'kmodBuild'), idparts))

    def connect_message(self, idn_param='IDN', begin_time=None):
        idn = {'vendor': None, 'model': None,
               'serial': None, 'fwVersion': None,
               'swVersion': None, 'kmodVersion': None
               }
        idn.update(self.get(idn_param))
        t = time.time() - (begin_time or self._t0)

        con_msg = ('Connected to: {vendor} {model} '
                   '(serial:{serial}, fwVersion:{fwVersion} '
                   'swVersion:{swVersion}, kmodVersion:{kmodVersion}) '
                   'in {t:.2f}s'.format(t=t, **idn))
        print(con_msg)

    # initialization functions
    def prepare_SSB_weight_and_rotation(self, IF,
                                        weight_function_I=1,
                                        weight_function_Q=2):
        trace_length = 4096
        tbase = np.arange(0, trace_length/5e8, 1/5e8)
        cosI = 127*np.array(np.cos(2*np.pi*IF*tbase))
        sinI = 127*np.array(np.sin(2*np.pi*IF*tbase))
        # first pair
        self.set('ch1_weight{}_data'.format(weight_function_I), np.array(cosI))
        self.set('ch2_weight{}_data'.format(weight_function_I), np.array(sinI))
        # second pair
        self.set('ch1_weight{}_data'.format(weight_function_Q), np.array(sinI))
        self.set('ch2_weight{}_data'.format(weight_function_Q), np.array(cosI))

        # setting the rotation matrices... very danagerous
        self.set(
            'ch_pair1_weight{}_rotmat_rotmat00'.format(weight_function_I), 1)
        self.set(
            'ch_pair1_weight{}_rotmat_rotmat01'.format(weight_function_I), 1)
        self.set(
            'ch_pair1_weight{}_rotmat_rotmat00'.format(weight_function_Q), -1)
        self.set(
            'ch_pair1_weight{}_rotmat_rotmat01'.format(weight_function_Q), 1)

    def prepare_DSB_weight_and_rotation(self, IF,
                                        weight_function_I=1,
                                        weight_function_Q=2):
        trace_length = 4096
        tbase = np.arange(0, trace_length/5e8, 1/5e8)
        cosI = 127*np.array(np.cos(2*np.pi*IF*tbase))
        sinI = 127*np.array(np.sin(2*np.pi*IF*tbase))

        # first pair
        self.set('ch1_weight{}_data'.format(weight_function_I), np.array(cosI))
        self.set('ch2_weight{}_data'.format(weight_function_I), np.array(sinI))
        # second pair
        self.set('ch1_weight{}_data'.format(weight_function_Q), np.array(sinI))
        self.set('ch2_weight{}_data'.format(weight_function_Q), np.array(cosI))

        # setting the rotation matrices... very danagerous
        self.set(
            'ch_pair1_weight{}_rotmat_rotmat00'.format(weight_function_I), 1)
        self.set(
            'ch_pair1_weight{}_rotmat_rotmat01'.format(weight_function_I), 0)
        self.set(
            'ch_pair1_weight{}_rotmat_rotmat00'.format(weight_function_Q), 1)
        self.set(
            'ch_pair1_weight{}_rotmat_rotmat01'.format(weight_function_Q), 0)

    def _read_parameter_limits(self):
        path = os.path.abspath(__file__)
        dir_path = os.path.dirname(path)
        parameters_folder_path = os.path.join(dir_path,
                                              'QuTech_DDM_Parameter_Files')

        path = os.path.join(parameters_folder_path,
                            'QuTech_DDM_Parameter_Limits.txt')

        if not os.path.exists(parameters_folder_path):
            os.makedirs(parameters_folder_path)

        try:
            file = open(path, "a+")
        except Exception as e:
            log.warning("failed to open " + path + ".(%s)", str(e))
        try:
            file_content = json.loads(file.read())
            self.ranges_file_version = file_content["version"][
                "ddm_software_version"]
        except Exception as e:
            self.ranges_file_version = 'NaN'

        if ('swBuild' in self.version_info
                and self.version_info['swBuild'] == self.ranges_file_version):
            results = file_content["parameters"]
            self.parameter_limits_list_is_incomplete = False
        else:
            results = {}

        return results

    def _read_ddm_parameters(self):
        path = os.path.abspath(__file__)
        dir_path = os.path.dirname(path)
        parameters_folder_path = os.path.join(dir_path,
                                              'QuTech_DDM_Parameter_Files')

        # Open the file and read the version number
        self._s_file_name = os.path.join(
            parameters_folder_path, 'QuTech_DDM_Parameters.txt')

        if not os.path.exists(parameters_folder_path):
            os.makedirs(parameters_folder_path)

        try:
            file = open(self._s_file_name, "a+")
        except Exception as e:
            log.warning("parameter file for gettable parameters {} not" +
                        " found".format(self._s_file_name) + ".(%s)", str(e))
        try:
            file_content = json.loads(file.read())
            self.parameter_file_version = file_content["version"]["software"]
        except Exception as e:
            self.parameter_file_version = 'NaN'

        if ('swBuild' in self.version_info and
                self.version_info['swBuild'] == self.parameter_file_version):
            # Return the parameter list given by the txt file
            results = file_content["parameters"]
        else:
            # Update the parameter list to the data that is given by the ddm
            parameters_str = self.ask('qutech:parameters?')
            parameters_str = parameters_str.replace('\t', '\n')
            try:
                file = open(self._s_file_name, 'w')
                file.write(parameters_str)
            except Exception as e:
                log.warning("failed to write update the parameters in the" +
                            " parameter file" + ".(%s)", str(e))
            results = json.loads(parameters_str)["parameters"]
        return results

    def _store_parameter_limits(self):
        path = os.path.abspath(__file__)
        dir_path = os.path.dirname(path)
        parameters_folder_path = os.path.join(dir_path,
                                              'QuTech_DDM_Parameter_Files')

        self.ranges_file_name = os.path.join(parameters_folder_path,
                                             'QuTech_DDM_Parameter_Limits.txt')
        version = {}
        version["ddm_software_version"] = self.version_info['swBuild']
        file_content = {}
        file_content["version"] = version
        file_content["parameters"] = self.list_of_parameter_limits
        file = open(self.ranges_file_name, 'w')
        json.dump(file_content, file,  indent=2)

    #################
    # Error handling
    #################

    class Error(object):

        def __init__(self, errorCode, description, logLevel, acquisitionMode):
            self.errorCode = errorCode
            self.description = description
            self.logLevel = logLevel
            self.acquisitionMode = acquisitionMode

        def __repr__(self):
            level = ""
            if (self.logLevel >= logging.CRITICAL):
                level = "critical"
            elif (self.logLevel >= logging.ERROR):
                level = "error"
            elif (self.logLevel >= logging.WARNING):
                level = "warning"
            elif (self.logLevel >= logging.INFO):
                level = "info"
            elif (self.logLevel >= logging.DEBUG):
                level = "debug"
            else:
                level = "notset"
            result = str(self.logLevel) + " " + level + ": " + self.description
            if (len(self.acquisitionMode) > 0):
                result += "(" + self.acquisitionMode + ")"
            return result

        def log(self):
            if (self.logLevel >= logging.CRITICAL):
                log.critical(self)
            elif (self.logLevel >= logging.ERROR):
                log.error(self)
            elif (self.logLevel >= logging.WARNING):
                log.warning(self)
            elif (self.logLevel >= logging.INFO):
                log.info(self)
            elif (self.logLevel >= logging.DEBUG):
                log.debug(self)

    def _displayErrors(self, errors):
        for i in range(0, len(errors)):
            if (errors[i].logLevel >= self.exceptionLevel):
                raise Exception(errors[i])
            else:
                errors[i].log()

    def _parseErrorList(self, acquisitionMode, errorList):
        results = []
        errors = json.loads(errorList)
        for error in errors:
            if error['error_code']:
                results.append(self.Error(error['error_code'],
                                          error['description'],
                                          error['error_level'],
                                          acquisitionMode))
        return results

    def _getInAvgErrors(self, acquisitionMode, ch):
        return self._parseErrorList(acquisitionMode, self.ask(
            'qutech:channel{:d}:errors?'.format(ch))
        )

    def _getErrors(self, acquisitionMode, ch_pair, wNr):
        return self._parseErrorList(acquisitionMode, self.ask(
            'qutech:ADC{:d}:errors{:d}?'.format(ch_pair, wNr))
        )

    def _displayInAvgErrors(self, acquisitionMode, ch):
        self._displayErrors(self._getInAvgErrors(acquisitionMode, ch))

    def _displayQBitErrors(self, acquisitionMode, ch_pair, wNr):
        self._displayErrors(self._getErrors(acquisitionMode, ch_pair, wNr))

    # From this logging level, a message will cause and exceptions instead of
    # a log message
    def _setWarningLevel(self, level):
        self.exceptionLevel = level

    def _getWarningLevel(self):
        level = 'notset'
        if (self.exceptionLevel >= logging.CRITICAL):
            level = "critical"
        elif (self.exceptionLevel >= logging.ERROR):
            level = "error"
        elif (self.exceptionLevel >= logging.WARNING):
            level = "warning"
        elif (self.exceptionLevel >= logging.INFO):
            level = "info"
        elif (self.exceptionLevel >= logging.DEBUG):
            level = "debug"
        print("Waring Level: " + str(self.exceptionLevel) + " " + level +
              "\r\n")
        # Add the list with possible errors to the results
        print("Possible Errors: ")
        errors = json.loads(self.ask("QUTech:ERRor:LIST?"))
        for error in errors:
            if (error['error_code']
                    and error['error_level'] >= self.exceptionLevel):
                print(str(self.Error(error['error_code'],
                                     error['description'],
                                     error['error_level'],
                                     "")))
        return self.exceptionLevel

    def _setDisplayProgressEnabled(self, val):
        self.printAcquisitionProgress = val

    def _getDisplayProgressEnabled(self):
        return self.printAcquisitionProgress
